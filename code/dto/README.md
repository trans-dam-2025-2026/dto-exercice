# ğŸš€ Projet DTO â€“ Data Transfer Objects

Ce projet fournit les modÃ¨les de donnÃ©es (**DTO**) utilisÃ©s dans lâ€™Ã©cosystÃ¨me **DTA (Data Transfer Architecture)**.  
Ces modÃ¨les assurent une **structure cohÃ©rente, typÃ©e et sÃ©rialisable** pour toutes les entitÃ©s mÃ©tiers de lâ€™application.

Ils sont :

- GÃ©nÃ©rÃ©s automatiquement avec **Freezed** et **JsonSerializable**
- IntÃ©grÃ©s Ã  **Cloud Firestore** via **Firestore ODM**
- IndÃ©pendants du backend (pouvant Ãªtre utilisÃ©s ailleurs sans dÃ©pendre de Firestore)

---

## ğŸ“ Structure du projet

```
lib/
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ user.dart                       # Model User (avec @freezed + @Collection)
â”‚   â”œâ”€â”€ user.freezed.dart               # GÃ©nÃ©rÃ© par Freezed
â”‚   â”œâ”€â”€ user.g.dart                     # GÃ©nÃ©rÃ© par json_serializable
â”‚
â”‚   â”œâ”€â”€ team.dart                       # Model Team
â”‚   â”œâ”€â”€ team.freezed.dart               # GÃ©nÃ©rÃ© automatiquement
â”‚   â”œâ”€â”€ team.g.dart                     # GÃ©nÃ©rÃ© automatiquement
â”‚
â”‚   â”œâ”€â”€ my_transaction.dart             # Model MyTransaction
â”‚   â”œâ”€â”€ my_transaction.freezed.dart     # GÃ©nÃ©rÃ© automatiquement
â”‚   â”œâ”€â”€ my_transaction.g.dart           # GÃ©nÃ©rÃ© automatiquement
â”‚
â”œâ”€â”€ schema.dart                         # DÃ©finition du schÃ©ma ODM (avec @Schema et @Collection)
â”œâ”€â”€ schema.odm.dart                     # Fichier gÃ©nÃ©rÃ© par Firestore ODM
â”‚
â”œâ”€â”€ dto.dart                            # Point dâ€™entrÃ©e du package (exporte tous les modÃ¨les)
â””â”€â”€ ...

```


---

## âš™ï¸ Installation

Dans ton projet Flutter principal (ex: `push_data_firestore`), ajoute le package DTO localement :

```yaml
dependencies:
  dto:
    path: ../dto
  firestore_odm: ^3.0.2
```
Ensuite, installe les dÃ©pendances nÃ©cessaires :
```
flutter pub get
```
---
## ğŸ§  Concepts
### ğŸ”¸ 1. DTOs (Data Transfer Objects)

Chaque classe (`User`, `Team`, `MyTransaction`) :
- Est dÃ©finie avec `@freezed`
- SÃ©rialisable en JSON (`fromJson`, `toJson`)
- Compatible avec **Firestore ODM** via `@Collection`, `@DocumentIdField`, etc.

### ğŸ”¸ 2. ODM (Object Document Mapper)

GrÃ¢ce Ã  Firestore ODM, on peut manipuler Firestore comme un ORM :
```
await db.teams.insert(team);
await db.teams(team.id).transactions.insert(transaction);
```
ğŸ’¡ **Plus besoin de**  
`FirebaseFirestore.instance.collection('teams')` ni de `doc().set()` manuels
--- 
## ğŸ“¦ Les modÃ¨les principaux
### ğŸ§â€â™‚ï¸ User
```
@freezed
class User with _$User {
    const factory User({
        @DocumentIdField() String? id,
        required String firstName,
        required String lastName,
        required String email,
    }) = _User;

    factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}
```

**Exemple dâ€™utilisation :**
```
final user = User(
    firstName: 'Ada',
    lastName: 'Lovelace',
    email: 'ada@example.com',
);

await db.users.insert(user);
```
---
### ğŸ’¸ MyTransaction
```
@freezed
class MyTransaction with _$MyTransaction {
    const factory MyTransaction({
        @DocumentIdField() String? id,
        required String title,
        required double amount,
        required DateTime date,
        String? description,
    }) = _MyTransaction;

    factory MyTransaction.fromJson(Map<String, dynamic> json) =>
        _$MyTransactionFromJson(json);
}
```

**Exemple :**
```
final tx = MyTransaction(
    title: "DÃ©jeuner d'Ã©quipe",
    amount: 42.5,
    date: DateTime.now(),
    description: "Pizzas ğŸ• partagÃ©es",
);
await db.teams('team123').transactions.insert(tx);
```
---
### ğŸ‘¥ Team
```
@freezed
class Team with _$Team {
    const factory Team({
        @DocumentIdField() String? id,
        required String title,
        required DateTime startDate,
        required List<String> users,
        String? picturePath,
        List<String>? tags,
    }) = _Team;

    factory Team.fromJson(Map<String, dynamic> json) => _$TeamFromJson(json);
}
```

**Exemple dâ€™utilisation :**
```
final team = Team(
    id: FirestoreODM.autoGeneratedId,
    title: 'ğŸ’» Code Magicians',
    startDate: DateTime(2025, 10, 31),
    users: ['ada@example.com', 'alan@example.com'],
    tags: ['Coding', 'Magic'],
);

await db.teams.insert(team);
```
---
## ğŸ§© App Schema (Firestore ODM)

Le schÃ©ma ODM dÃ©finit la hiÃ©rarchie des collections et sous-collections :
```
@Schema()
@Collection<User>('users')
@Collection<Team>('teams')
@Collection<MyTransaction>('teams/*/transactions')
@Collection<User>('teams/*/transactions/*/concerns')
final appSchema = _$AppSchema;
```

Il est ensuite instanciÃ© dans ton code :
```
final db = FirestoreODM(appSchema, firestore: FirebaseFirestore.instance);
```
---
## ğŸ§± Exemples dâ€™utilisation Firestore ODM
### Ajouter une Ã©quipe
```
final team = Team(
    id: FirestoreODM.autoGeneratedId,
    title: 'Voyage Ã  Barcelone',
    startDate: DateTime(2024, 6, 10),
    users: ['dylan@mail.com', 'john@mail.com'],
);
await db.teams.insert(team);
```

### Ajouter une transaction Ã  une Ã©quipe
```
final transaction = MyTransaction(
    title: 'HÃ´tel Barcelone',
    amount: 250,
    date: DateTime.now(),
);
await db.teams(team.id!).transactions.insert(transaction);
```
### Ajouter un utilisateur concernÃ©
```
final user = User(
    firstName: "John",
    lastName: "Doe",
    email: "john@mail.com",
);

await db.teams(team.id!).transactions(transaction.id!).concerns.insert(user);
```
---
## âš¡ GÃ©nÃ©ration de code

Chaque fois que tu modifies un modÃ¨le DTO (@freezed, @Collection, etc.),
tu dois rÃ©gÃ©nÃ©rer le code :

```
dart run build_runner build --delete-conflicting-outputs
```

---
## ğŸ§± DÃ©tacher les DTOs de Firestore

Les DTOs peuvent Ãªtre utilisÃ©s **sans Firestore**, par exemple pour :

- La **sÃ©rialisation locale** (`JSON`)
- La **manipulation de donnÃ©es mockÃ©es**
- Les **tests unitaires**

> Il suffit dâ€™ignorer les champs `@DocumentIdField()`  
> et dâ€™utiliser simplement `toJson()` / `fromJson()` normalement.

---
### âœ… Bonnes pratiques

- Toujours utiliser **`FirestoreODM.autoGeneratedId`** pour crÃ©er un nouvel objet.
- Ne pas inclure manuellement `id` dans `toJson()`.
- Bien valider les listes (`tags`, `users`) avant insertion.
- GÃ©nÃ©rer le code aprÃ¨s toute modification de modÃ¨le :
```
  dart run build_runner build --delete-conflicting-outputs
```
- VÃ©rifier la hiÃ©rarchie des sous-collections dans schema.dart.

---
### ğŸ’¡ Exemple de flux complet

``` 
final db = FirestoreODM(appSchema, firestore: FirebaseFirestore.instance);

// 1.ï¸ CrÃ©er une Ã©quipe
final team = Team(
    id: FirestoreODM.autoGeneratedId,
    title: 'ğŸŒ´ Voyage Ã  Bali',
    startDate: DateTime(2025, 3, 12),
    users: ['ada@mail.com', 'grace@mail.com'],
);

await db.teams.insert(team);

// 2. Ajouter une transaction
final tx = MyTransaction(
    title: 'Vol aller',
    amount: 420,
    date: DateTime.now(),
);
await db.teams(team.id!).transactions.insert(tx);

// 3. Ajouter un concernÃ©
final user = User(firstName: 'Ada', lastName: 'Lovelace', email: 'ada@mail.com');

await db.teams(team.id!).transactions(tx.id!).concerns.insert(user);
```